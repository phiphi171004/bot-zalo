const express = require('express');
const bodyParser = require('body-parser');
const axios = require('axios');
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));

// Kh·ªüi t·∫°o Gemini (mi·ªÖn ph√≠!)
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash" });

// Zalo Bot API Configuration (Official)
const ZALO_BOT_API_BASE = 'https://bot-api.zapps.me/bot';
const BOT_TOKEN = process.env.ZALO_BOT_TOKEN;
const SECRET_TOKEN = process.env.ZALO_SECRET_TOKEN;
const WEBHOOK_URL = process.env.WEBHOOK_URL;

// L∆∞u tr·ªØ l·ªãch s·ª≠ chat (trong production n√™n d√πng database)
const chatHistory = new Map();

// L∆∞u tr·ªØ model preference c·ªßa t·ª´ng user
const userModels = new Map();

// Danh s√°ch models c√≥ s·∫µn
const AVAILABLE_MODELS = {
  'flash': {
    name: 'gemini-1.5-flash',
    display: '‚ö° Flash (Nhanh)',
    description: 'Ph·∫£n h·ªìi nhanh, ph√π h·ª£p chat th∆∞·ªùng'
  },
  'pro': {
    name: 'gemini-1.5-pro',
    display: 'üß† Pro (Th√¥ng minh)', 
    description: 'Suy lu·∫≠n s√¢u, gi·∫£i to√°n, l·∫≠p tr√¨nh ph·ª©c t·∫°p'
  },
  'flash-8b': {
    name: 'gemini-1.5-flash-8b',
    display: 'üî• Flash 8B (·ªîn ƒë·ªãnh)',
    description: 'Model nh·∫π, √≠t b·ªã overload'
  }
};

// Fallback models khi b·ªã overload
const FALLBACK_MODELS = ['gemini-1.5-flash-8b', 'gemini-1.5-flash', 'gemini-1.5-pro'];

// H√†m l·∫•y model hi·ªán t·∫°i c·ªßa user
function getUserModel(userId, taskType = 'text') {
  const modelKey = userModels.get(userId) || 'auto';
  
  // N·∫øu ch·∫ø ƒë·ªô AUTO, ch·ªâ d√πng c√°c model nhanh
  if (modelKey === 'auto') {
    if (taskType === 'image') {
      return AVAILABLE_MODELS['flash']; // Flash t·ªët cho vision
    } else if (taskType === 'math' || taskType === 'code') {
      return AVAILABLE_MODELS['flash-8b']; // Flash 8B ·ªïn ƒë·ªãnh cho logic
    } else {
      return AVAILABLE_MODELS['flash']; // Flash cho chat th∆∞·ªùng
    }
  }
  
  return AVAILABLE_MODELS[modelKey];
}

// H√†m l√†m s·∫°ch markdown cho Zalo
function cleanMarkdownForZalo(text) {
  return text
    // X√≥a c√¢u ch√†o t·ª± ƒë·ªông t·ª´ Gemini
    .replace(/^üî•\s*Gemini\s*Bot\s*ƒë√¢y!?\s*üòä?\s*\n?/i, '')  // X√≥a "üî• Gemini Bot ƒë√¢y! üòä"
    .replace(/^Xin\s*ch√†o!?\s*T√¥i\s*l√†\s*Gemini\s*Bot\s*[.!]?\s*\n?/i, '')  // X√≥a "Xin ch√†o! T√¥i l√† Gemini Bot."
    .replace(/^Ch√†o\s*b·∫°n!?\s*T√¥i\s*l√†\s*Gemini\s*Bot\s*[.!]?\s*\n?/i, '')  // X√≥a "Ch√†o b·∫°n! T√¥i l√† Gemini Bot."
    // X√≥a markdown formatting
    .replace(/\*\*(.*?)\*\*/g, '$1')  // **bold** ‚Üí bold
    .replace(/\*(.*?)\*/g, '$1')      // *italic* ‚Üí italic
    .replace(/`(.*?)`/g, '$1')        // `code` ‚Üí code
    .replace(/#{1,6}\s/g, '')         // # headers ‚Üí text
    .replace(/^\s*[-*+]\s/gm, '‚Ä¢ ')   // - list ‚Üí ‚Ä¢ list
    .replace(/^\s*\d+\.\s/gm, '‚Ä¢ ')   // 1. numbered ‚Üí ‚Ä¢ list
    .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1') // [text](link) ‚Üí text
    .replace(/```[\s\S]*?```/g, (match) => {
      // X·ª≠ l√Ω code blocks
      return match
        .replace(/```\w*\n?/g, '')  // X√≥a ```
        .replace(/```/g, '')        // X√≥a ```
        .trim();
    })
    // L√†m s·∫°ch whitespace th·ª´a
    .replace(/\n{3,}/g, '\n\n')       // Gi·∫£m line breaks th·ª´a
    .replace(/^\s+|\s+$/g, '')        // Trim ƒë·∫ßu cu·ªëi
    .trim();
}

// Middleware x√°c th·ª±c secret token t·ª´ Zalo
function verifyZaloRequest(req, res, next) {
  const receivedToken = req.headers['x-bot-api-secret-token'];
  
  if (receivedToken !== SECRET_TOKEN) {
    console.log('‚ùå Invalid secret token:', receivedToken);
    return res.status(401).json({ error: 'Unauthorized' });
  }
  
  next();
}

// H√†m setup webhook t·ª± ƒë·ªông
async function setupWebhook() {
  try {
    const response = await axios.post(`${ZALO_BOT_API_BASE}${BOT_TOKEN}/setWebhook`, {
      url: WEBHOOK_URL,
      secret_token: SECRET_TOKEN
    });
    
    console.log('üì° Webhook response:', response.data);
    
    // Ki·ªÉm tra k·∫øt qu·∫£ th·ª±c t·∫ø
    if (response.data.ok === false) {
      throw new Error(`Webhook setup failed: ${response.data.description} (${response.data.error_code})`);
    }
    
    console.log('‚úÖ Webhook ƒë√£ ƒë∆∞·ª£c c·∫•u h√¨nh th√†nh c√¥ng!');
    return response.data;
  } catch (error) {
    console.error('‚ùå L·ªói c·∫•u h√¨nh webhook:', error.response?.data || error.message);
    throw error;
  }
}

// H√†m g·ª≠i chat action (hi·ªÉn th·ªã "ƒëang g√µ")
async function sendChatAction(chatId, action = 'typing') {
  try {
    const response = await axios.post(`${ZALO_BOT_API_BASE}${BOT_TOKEN}/sendChatAction`, {
      chat_id: chatId,
      action: action
    });
    
    console.log('‚å®Ô∏è ƒê√£ g·ª≠i chat action:', action);
    return response.data;
  } catch (error) {
    console.error('‚ùå L·ªói g·ª≠i chat action:', error.response?.data || error.message);
    // Kh√¥ng throw error v√¨ ƒë√¢y ch·ªâ l√† t√≠nh nƒÉng ph·ª•
  }
}

// H√†m g·ª≠i tin nh·∫Øn ƒë·∫øn Zalo (Bot API)
async function sendZaloMessage(chatId, message) {
  try {
    const response = await axios.post(`${ZALO_BOT_API_BASE}${BOT_TOKEN}/sendMessage`, {
      chat_id: chatId,
      text: message
    });
    
    console.log('‚úÖ ƒê√£ g·ª≠i tin nh·∫Øn th√†nh c√¥ng:', response.data);
    return response.data;
  } catch (error) {
    console.error('‚ùå L·ªói khi g·ª≠i tin nh·∫Øn:', error.response?.data || error.message);
    throw error;
  }
}

// H√†m download ·∫£nh t·ª´ URL
async function downloadImageAsBase64(imageUrl) {
  try {
    const response = await axios.get(imageUrl, { responseType: 'arraybuffer' });
    const base64 = Buffer.from(response.data, 'binary').toString('base64');
    let mimeType = response.headers['content-type'] || 'image/jpeg';
    
    // Fix MIME type cho Gemini
    if (mimeType === 'image/jpg') {
      mimeType = 'image/jpeg';
    }
    
    console.log(`üì∏ Downloaded image: ${mimeType}, size: ${base64.length} chars`);
    return { base64, mimeType };
  } catch (error) {
    console.error('‚ùå L·ªói download ·∫£nh:', error.message);
    throw error;
  }
}



// H√†m x·ª≠ l√Ω v·ªõi Gemini (mi·ªÖn ph√≠!)
async function getGeminiResponse(message, userId, imageUrl = null) {
  try {
    // L·∫•y l·ªãch s·ª≠ chat c·ªßa user
    let history = chatHistory.get(userId) || [];
    
    // L·∫•y model preference c·ªßa user (t·ª± ƒë·ªông detect task type)
    let taskType = 'text';
    if (imageUrl) taskType = 'image';
    else if (message.includes('code') || message.includes('l·∫≠p tr√¨nh') || message.includes('thu·∫≠t to√°n')) taskType = 'code';
    else if (message.includes('to√°n') || message.includes('t√≠nh') || message.includes('ph∆∞∆°ng tr√¨nh')) taskType = 'math';
    
    const userModel = getUserModel(userId, taskType);
    const currentModel = genAI.getGenerativeModel({ model: userModel.name });
    
    console.log(`üéØ S·ª≠ d·ª•ng model: ${userModel.display} (task: ${taskType})`);
    
    // T·∫°o context t·ª´ l·ªãch s·ª≠ chat
    let contextPrompt = `B·∫°n l√† m·ªôt AI assistant th√¥ng minh v√† h·ªØu √≠ch t√™n l√† Gemini Bot (${userModel.display}). H√£y tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát m·ªôt c√°ch t·ª± nhi√™n v√† th√¢n thi·ªán. 

QUAN TR·ªåNG: 
1. Tr·∫£ l·ªùi b·∫±ng vƒÉn b·∫£n thu·∫ßn t√∫y, KH√îNG s·ª≠ d·ª•ng markdown formatting nh∆∞ **, *, #, backticks, []() v√¨ ƒë√¢y l√† chat tr√™n Zalo. S·ª≠ d·ª•ng emoji v√† k√Ω t·ª± ƒë·∫∑c bi·ªát ƒë·ªÉ l√†m ƒë·∫πp tin nh·∫Øn thay v√¨ markdown.
2. KH√îNG t·ª± th√™m "üî• Gemini Bot ƒë√¢y! üòä" ho·∫∑c b·∫•t k·ª≥ c√¢u ch√†o n√†o v√†o ƒë·∫ßu c√¢u tr·∫£ l·ªùi.
3. Tr·∫£ l·ªùi tr·ª±c ti·∫øp v√†o n·ªôi dung, kh√¥ng c·∫ßn gi·ªõi thi·ªáu b·∫£n th√¢n.

B·∫°n c√≥ th·ªÉ gi√∫p vi·∫øt code, gi·∫£i th√≠ch ki·∫øn th·ª©c, d·ªãch thu·∫≠t v√† nhi·ªÅu vi·ªác kh√°c.

`;
    
    // Th√™m l·ªãch s·ª≠ chat v√†o context (gi·ªØ 10 tin nh·∫Øn g·∫ßn nh·∫•t)
    if (history.length > 0) {
      const recentHistory = history.slice(-10);
      contextPrompt += "L·ªãch s·ª≠ cu·ªôc tr√≤ chuy·ªán:\n";
      recentHistory.forEach(msg => {
        const role = msg.role === 'user' ? 'Ng∆∞·ªùi d√πng' : 'Bot';
        contextPrompt += `${role}: ${msg.content}\n`;
      });
      contextPrompt += "\n";
    }
    
    contextPrompt += `C√¢u h·ªèi hi·ªán t·∫°i: ${message}`;
    
    // G·ªçi Gemini API v·ªõi retry mechanism
    let result;
    let attempts = 0;
    const maxAttempts = 3;
    
    while (attempts < maxAttempts) {
      try {
        attempts++;
        
        // Ch·ªçn model (th·ª≠ fallback n·∫øu kh√¥ng ph·∫£i l·∫ßn ƒë·∫ßu)
        let modelToUse = currentModel;
        if (attempts > 1) {
          const fallbackModelName = FALLBACK_MODELS[attempts - 2];
          if (fallbackModelName) {
            modelToUse = genAI.getGenerativeModel({ model: fallbackModelName });
            console.log(`üîÑ Retry ${attempts} v·ªõi model: ${fallbackModelName}`);
          }
        }
        
        if (imageUrl) {
          // X·ª≠ l√Ω v·ªõi ·∫£nh (Gemini Vision)
          console.log('üñºÔ∏è Ph√¢n t√≠ch ·∫£nh v·ªõi Gemini Vision...');
          const imageData = await downloadImageAsBase64(imageUrl);
          
          const prompt = `${contextPrompt}

Ng∆∞·ªùi d√πng ƒë√£ g·ª≠i k√®m m·ªôt h√¨nh ·∫£nh. H√£y ph√¢n t√≠ch ·∫£nh v√† tr·∫£ l·ªùi c√¢u h·ªèi d·ª±a tr√™n n·ªôi dung ·∫£nh.`;

          result = await modelToUse.generateContent([
            prompt,
            {
              inlineData: {
                data: imageData.base64,
                mimeType: imageData.mimeType
              }
            }
          ]);
        } else {
          // X·ª≠ l√Ω text th√¥ng th∆∞·ªùng
          result = await modelToUse.generateContent(contextPrompt);
        }
        
        // N·∫øu th√†nh c√¥ng, tho√°t loop
        break;
        
      } catch (error) {
        console.error(`‚ùå L·ªói attempt ${attempts}:`, error.message);
        
        if (attempts >= maxAttempts) {
          // H·∫øt attempts, throw error
          throw error;
        }
        
        // ƒê·ª£i 1-2 gi√¢y tr∆∞·ªõc khi retry
        await new Promise(resolve => setTimeout(resolve, 1000 + (attempts * 500)));
      }
    }
    
    let aiResponse = result.response.text();
    
    // L√†m s·∫°ch format markdown cho Zalo
    aiResponse = cleanMarkdownForZalo(aiResponse);
    
    // Th√™m v√†o l·ªãch s·ª≠
    history.push({ role: 'user', content: message });
    history.push({ role: 'assistant', content: aiResponse });
    
    // Gi·ªõi h·∫°n l·ªãch s·ª≠ (gi·ªØ 20 tin nh·∫Øn g·∫ßn nh·∫•t)
    if (history.length > 20) {
      history = history.slice(-20);
    }
    
    chatHistory.set(userId, history);
    
    return aiResponse;
  } catch (error) {
    console.error('‚ùå L·ªói Gemini API:', error.response?.data || error.message);
    return 'ü§ñ Xin l·ªói, t√¥i ƒëang g·∫∑p s·ª± c·ªë k·ªπ thu·∫≠t. Vui l√≤ng th·ª≠ l·∫°i sau.';
  }
}

// Webhook endpoint ƒë·ªÉ nh·∫≠n tin nh·∫Øn t·ª´ Zalo
app.post('/webhook', verifyZaloRequest, async (req, res) => {
  try {
    console.log('üì® Nh·∫≠n webhook:', JSON.stringify(req.body, null, 2));
    
    const { event_name, message } = req.body;
    
    // X·ª≠ l√Ω tin nh·∫Øn text
    if (event_name === 'message.text.received' && message && message.text) {
      const chatId = message.chat.id;
      const userId = message.from.id;
      const userMessage = message.text;
      const userName = message.from.display_name || 'B·∫°n';
      
      console.log(`üí¨ Tin nh·∫Øn text t·ª´ ${userName} (${userId}): ${userMessage}`);
      
      // X·ª≠ l√Ω c√°c l·ªánh ƒë·∫∑c bi·ªát
      if (userMessage.toLowerCase() === '/start') {
        await sendZaloMessage(chatId, `Xin ch√†o ${userName}! üëã

ü§ñ T√¥i l√† Gemini Bot tr√™n Zalo. T√¥i c√≥ th·ªÉ:
‚Ä¢ Tr·∫£ l·ªùi c√¢u h·ªèi v·ªÅ m·ªçi ch·ªß ƒë·ªÅ
‚Ä¢ Vi·∫øt v√† gi·∫£i th√≠ch code
‚Ä¢ D·ªãch thu·∫≠t ƒëa ng√¥n ng·ªØ  
‚Ä¢ Gi·∫£i th√≠ch ki·∫øn th·ª©c ph·ª©c t·∫°p
‚Ä¢ S√°ng t·∫°o n·ªôi dung
‚Ä¢ üì∏ Ph√¢n t√≠ch ·∫£nh (OCR, m√¥ t·∫£)
‚Ä¢ üìã Ph√¢n t√≠ch text/code ƒë∆∞·ª£c paste
‚Ä¢ V√† nhi·ªÅu th·ª© kh√°c!

üí° H√£y chat b√¨nh th∆∞·ªùng v·ªõi t√¥i nh∆∞ ChatGPT nh√©! (Powered by Google Gemini)

üìù L·ªánh h·ªØu √≠ch:
/help - Xem h∆∞·ªõng d·∫´n
/clear - X√≥a l·ªãch s·ª≠ chat
/model - Xem/ch·ªçn AI model`);

        } else if (userMessage.toLowerCase() === '/clear') {
          chatHistory.delete(userId);
          await sendZaloMessage(chatId, 'üóëÔ∏è ƒê√£ x√≥a l·ªãch s·ª≠ chat. B·∫Øt ƒë·∫ßu cu·ªôc tr√≤ chuy·ªán m·ªõi!');
          
        } else if (userMessage.toLowerCase() === '/model') {
          // Hi·ªÉn th·ªã model hi·ªán t·∫°i v√† danh s√°ch
          const currentModelKey = userModels.get(userId) || 'flash';
          const currentModel = getUserModel(userId);
          
          let modelList = `ü§ñ Model hi·ªán t·∫°i: ${currentModel.display}`;
          if (currentModelKey === 'auto') {
            modelList += ` (AUTO - t·ª± ƒë·ªông ch·ªçn)`;
          }
          modelList += `\n\nüìã Danh s√°ch models:\n\n`;
          
          // Hi·ªÉn th·ªã AUTO mode
          const autoCheck = currentModelKey === 'auto' ? '‚úÖ ' : '   ';
          modelList += `${autoCheck}üéØ AUTO (Khuy·∫øn ngh·ªã)\n   T·ª± ƒë·ªông ch·ªçn model ph√π h·ª£p\n   L·ªánh: /model auto\n\n`;
          
          Object.entries(AVAILABLE_MODELS).forEach(([key, model]) => {
            const current = userModels.get(userId) === key ? '‚úÖ ' : '   ';
            modelList += `${current}${model.display}\n   ${model.description}\n   L·ªánh: /model ${key}\n\n`;
          });
          
          modelList += `üí° C√°ch d√πng:\n/model auto - T·ª± ƒë·ªông NHANH (khuy·∫øn ngh·ªã)\n/model flash - Lu√¥n d√πng Flash\n/model pro - Th√¥ng minh nh∆∞ng CH·∫¨M`;
          
          await sendZaloMessage(chatId, modelList);
          
        } else if (userMessage.toLowerCase().startsWith('/model ')) {
          // Chuy·ªÉn ƒë·ªïi model
          const modelKey = userMessage.toLowerCase().replace('/model ', '').trim();
          
          if (modelKey === 'auto') {
            userModels.set(userId, 'auto');
            await sendZaloMessage(chatId, `üéØ ƒê√£ b·∫≠t ch·∫ø ƒë·ªô AUTO!

ü§ñ Bot s·∫Ω t·ª± ƒë·ªông ch·ªçn model NHANH:
‚Ä¢ üì∏ ·∫¢nh ‚Üí Flash (t·ªët cho vision)
‚Ä¢ üßÆ To√°n/Code ‚Üí Flash 8B (·ªïn ƒë·ªãnh)
‚Ä¢ üí¨ Chat th∆∞·ªùng ‚Üí Flash (nhanh)

‚ö° Ch·ªâ d√πng model nhanh, kh√¥ng d√πng Pro ƒë·ªÉ tr√°nh ch·∫≠m!

/model ƒë·ªÉ xem chi ti·∫øt`);
          } else if (AVAILABLE_MODELS[modelKey]) {
            userModels.set(userId, modelKey);
            const selectedModel = AVAILABLE_MODELS[modelKey];
            await sendZaloMessage(chatId, `‚úÖ ƒê√£ chuy·ªÉn sang model: ${selectedModel.display}

üìù ${selectedModel.description}

üéØ √Åp d·ª•ng cho: text, ·∫£nh, file

üí° D√πng /model auto ƒë·ªÉ bot t·ª± ch·ªçn model ph√π h·ª£p`);
          } else {
            const availableKeys = Object.keys(AVAILABLE_MODELS).join(', ');
            await sendZaloMessage(chatId, `‚ùå Model kh√¥ng h·ª£p l·ªá!

üìã Models c√≥ s·∫µn: ${availableKeys}, auto

üí° V√≠ d·ª•: /model pro ho·∫∑c /model auto`);
          }
          
        } else if (userMessage.toLowerCase() === '/help') {
          await sendZaloMessage(chatId, `üìö H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng Gemini Bot:

üîπ **Chat b√¨nh th∆∞·ªùng:** G·ª≠i b·∫•t k·ª≥ c√¢u h·ªèi n√†o
üîπ **/start** - Kh·ªüi ƒë·ªông bot v√† xem gi·ªõi thi·ªáu
üîπ **/clear** - X√≥a l·ªãch s·ª≠ cu·ªôc tr√≤ chuy·ªán
üîπ **/model** - Xem/ch·ªçn AI model (Flash/Pro)
üîπ **/help** - Hi·ªÉn th·ªã h∆∞·ªõng d·∫´n n√†y

üí° **V√≠ d·ª• s·ª≠ d·ª•ng:**
‚Ä¢ "Gi·∫£i th√≠ch thu·∫≠t to√°n bubble sort"
‚Ä¢ "Vi·∫øt code Python t√≠nh giai th·ª´a"
‚Ä¢ "D·ªãch sang ti·∫øng Anh: Xin ch√†o"
‚Ä¢ "T√≥m t·∫Øt cu·ªën s√°ch Sapiens"
‚Ä¢ üì∏ Ch·ª•p ·∫£nh code + "Review code n√†y"
‚Ä¢ üìã Paste code + "T√¨m l·ªói: [code]"

ü§ñ **Models AI:**
‚Ä¢ /model auto - T·ª± ƒë·ªông ch·ªçn (khuy·∫øn ngh·ªã)
‚Ä¢ /model flash - Chat nhanh
‚Ä¢ /model pro - Th√¥ng minh (ch·∫≠m h∆°n)

üéØ Bot nh·ªõ ng·ªØ c·∫£nh cu·ªôc tr√≤ chuy·ªán ƒë·ªÉ tr·∫£ l·ªùi ch√≠nh x√°c h∆°n!`);

                } else {
          // Chat b√¨nh th∆∞·ªùng v·ªõi Gemini
          console.log('ü§ñ ƒêang x·ª≠ l√Ω v·ªõi Gemini...');
          await sendChatAction(chatId, 'typing');
          const aiResponse = await getGeminiResponse(userMessage, userId);
          
          // G·ª≠i tr·ª±c ti·∫øp, ƒë·ªÉ Zalo t·ª± c·∫Øt n·∫øu c·∫ßn
          await sendZaloMessage(chatId, aiResponse);
        }
      }
      // X·ª≠ l√Ω tin nh·∫Øn c√≥ ·∫£nh
      else if (event_name === 'message.image.received' && message && message.photo_url) {
        const chatId = message.chat.id;
        const userId = message.from.id;
        const userName = message.from.display_name || 'B·∫°n';
        const imageUrl = message.photo_url;
        const caption = message.caption || 'Ph√¢n t√≠ch ·∫£nh n√†y gi√∫p t√¥i';
        
        console.log(`üñºÔ∏è Tin nh·∫Øn ·∫£nh t·ª´ ${userName} (${userId}): ${caption}`);
        console.log(`üì∏ URL ·∫£nh: ${imageUrl}`);
        
        try {
          // Hi·ªÉn th·ªã "ƒëang g√µ"
          await sendChatAction(chatId, 'typing');
          
          // Ph√¢n t√≠ch ·∫£nh v·ªõi Gemini Vision
          console.log('ü§ñ ƒêang ph√¢n t√≠ch ·∫£nh v·ªõi Gemini...');
          const aiResponse = await getGeminiResponse(caption, userId, imageUrl);
          
          // G·ª≠i tr·ª±c ti·∫øp v·ªõi prefix ·∫£nh
          await sendZaloMessage(chatId, `üñºÔ∏è ${aiResponse}`);
        } catch (error) {
          console.error('‚ùå L·ªói x·ª≠ l√Ω ·∫£nh:', error);
          await sendZaloMessage(chatId, 'üñºÔ∏è Xin l·ªói, t√¥i kh√¥ng th·ªÉ ph√¢n t√≠ch ·∫£nh n√†y. Vui l√≤ng th·ª≠ l·∫°i sau.');
        }
      }
      // X·ª≠ l√Ω message kh√¥ng h·ªó tr·ª£ (bao g·ªìm file uploads)
      else if (event_name === 'message.unsupported.received') {
        const chatId = message.chat.id;
        const userId = message.from.id;
        const userName = message.from.display_name || 'B·∫°n';
        
        console.log(`‚ùå Tin nh·∫Øn kh√¥ng h·ªó tr·ª£ t·ª´ ${userName} (${userId})`);
        
        await sendZaloMessage(chatId, `‚ùå Xin l·ªói ${userName}, t√¥i kh√¥ng h·ªó tr·ª£ file uploads!

üîÑ **Thay v√†o ƒë√≥:**

üì∏ **Ch·ª•p ·∫£nh** thay v√¨ g·ª≠i file
‚Ä¢ Ch·ª•p m√†n h√¨nh code/document  
‚Ä¢ G·ª≠i ·∫£nh + c√¢u h·ªèi
‚Ä¢ T√¥i s·∫Ω OCR v√† ph√¢n t√≠ch

üìã **Copy-paste text**
‚Ä¢ Copy n·ªôi dung c·∫ßn ph√¢n t√≠ch
‚Ä¢ Paste v√†o chat + c√¢u h·ªèi

üí° **V√≠ d·ª•:**
‚Ä¢ Ch·ª•p ·∫£nh code ‚Üí "Review code n√†y"
‚Ä¢ Paste: "T√¨m l·ªói: function test() {...}"

ü§ñ T√¥i h·ªó tr·ª£: TEXT v√† ·∫¢NH`);
      }
      
      res.status(200).json({ status: 'success' });
    } catch (error) {
      console.error('‚ùå L·ªói x·ª≠ l√Ω webhook:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  });

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ 
    status: 'OK', 
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    webhook_url: WEBHOOK_URL,
    bot_token_configured: !!BOT_TOKEN,
    gemini_configured: !!process.env.GEMINI_API_KEY
  });
});

// Endpoint ƒë·ªÉ setup webhook
app.post('/setup-webhook', async (req, res) => {
  try {
    const result = await setupWebhook();
    res.json({ success: true, result });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Endpoint ƒë·ªÉ test g·ª≠i tin nh·∫Øn
app.post('/test-send', async (req, res) => {
  try {
    const { chatId, message } = req.body;
    const result = await sendZaloMessage(chatId, message);
    res.json({ success: true, result });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});



// Kh·ªüi ƒë·ªông server v√† setup webhook
app.listen(PORT, async () => {
  console.log(`üöÄ Bot Zalo Gemini ƒëang ch·∫°y t·∫°i port ${PORT}`);
  console.log(`üì± Webhook URL: ${WEBHOOK_URL}`);
  console.log(`üîë Bot Token: ${BOT_TOKEN ? 'ƒê√£ c·∫•u h√¨nh' : 'Ch∆∞a c·∫•u h√¨nh'}`);
  console.log(`üîê Secret Token: ${SECRET_TOKEN ? 'ƒê√£ c·∫•u h√¨nh' : 'Ch∆∞a c·∫•u h√¨nh'}`);
  console.log(`ü§ñ Gemini API: ${process.env.GEMINI_API_KEY ? 'ƒê√£ c·∫•u h√¨nh' : 'Ch∆∞a c·∫•u h√¨nh'}`);
  
  // T·ª± ƒë·ªông setup webhook khi kh·ªüi ƒë·ªông
  if (WEBHOOK_URL && BOT_TOKEN && SECRET_TOKEN) {
    console.log('üîß ƒêang c·∫•u h√¨nh webhook t·ª± ƒë·ªông...');
    try {
      await setupWebhook();
      console.log('‚úÖ Webhook ƒë√£ ƒë∆∞·ª£c c·∫•u h√¨nh th√†nh c√¥ng!');
    } catch (error) {
      console.error('‚ùå Kh√¥ng th·ªÉ c·∫•u h√¨nh webhook:', error.message);
      console.log('üí° B·∫°n c√≥ th·ªÉ setup th·ªß c√¥ng b·∫±ng c√°ch POST ƒë·∫øn /setup-webhook');
    }
  } else {
    console.log('‚ö†Ô∏è Thi·∫øu th√¥ng tin ƒë·ªÉ setup webhook t·ª± ƒë·ªông');
  }
}); 
